Matthew McAlarney - memcalarney
Alison McNicholas - almcnicholas

Part 2:
	When tackling this problem, we used the Hilli Steele Approach with a barrier created by conditional variables. We used multiple threads in our solution which lead us to utilize locks and barriers. We use locks to indicate when a thread could edit data or access other information. This helped us to prevent data overwriting each other or a thread trying to access something and causing an error. We then used a barrier to allow our program to block a group of threads until all of the threads arrived at a critical section. In doing so we could ensure that all of the threads waited for each other when calculating prefix sums. This prevented errors and miscalculations relating to all of the threads not being present at that stage of the program. 
When running our solution, it starts by checking if there are 4 input arguments. This will tell us if we have enough input data to run our program correctly. Additionally, we check if there are fewer than two numbers for the prefix sum. We must check this condition to ensure we are able to compute the prefix sum. If any of these two conditions are false, we return an EXIT_FAILURE, if not we continue the program. 
	Next, We initialize a few of the variables that we will be using later in the program. Then, we set aside memory and then read in all of the contents of the filename through a helper function read_input_vector. We additionally will initialize the mutex lock, and use its default attributes. We used a mutex lock because it enforces limits on access to different resources when there are many threads. Another thing we do here is to check if the conditional variable cond 1 was initialized correctly. If not, it returns an error. 
	After all of the initializing, we start to create each thread from the threadlist using a loop. We then send each thread to the calculate prefix sum function with a pointer to the arguments. (specifically, each thread had its own set of arguments in which it was able to operate on and not affect each other) This allows all of the threads to have access to the arguments and operate accordingly.  In this process, we start by allocating memory for a heap for the thread. We then set the numth to the number of threads and the start index field to the current value of the interaction. When creating the actual thread we set it to the specific location in the threadlist, based on the allocation. We also use the default attributes (attr) and the function calculateprefixsum with the input of the arguments.
	The calculate prefix sum function is not locked so all of the threads can enter at a similar time and allow for concurrent computations to occur. We start by unpacking the args_struct and initializing the start and numth based on the arguments imputed. We then filled the first level of the computation of the finished array with the values of input according to the logic of the Hillis Steele algorithm. Next, we iterate over each row of the finished array, which is like iterating over each level of computation of the Hillis Steele Algorithm. We iterate to the log2(n), as the prefix sum will be complete when we reach that iteration. During each iteration, we have the thread call the barrier function and wait at this barrier until all of the threads have arrived. As a result, all threads can concurrently enter the next level of computation of the Hillis Steele algorithm. 
	Inside the barrier function, we use a mutex lock to lock the thread counter resource so that the outside threads cannot write to it at the same time as the thread that has obtained the lock. We have this function to specifically avoid deadlocks. We found when creating the algorithm that without this function, multiple threads would access the same data, causing both operations to cease. So, when the current thread enters, it increments the thread counter variable to reflect the current number of threads that have entered this section, the “critical section” of the algorithm. If not all of the threads have arrived, then the current thread entering must wait on the conditional variable cond1 and release the mutex lock so that other threads can enter the critical section. When this happens. The mutex is unlocked so the other threads can increment the thread counter. We do this here to ensure that the program can continue to run and not end up waiting for a thread to continue when it cannot. Then, if the current thread is the last thread to enter, we set the thread counter to 0 to reflect that all of the threads have entered. We then broadcast with the condition variable, cond1, that all threads are currently waiting or being blocked by con1 and that we should continue the execution into the next level of the Hillis Steele algorithm. Additionally, at this point, we unlock the mutex lock so all of the threads can continue execution. 
	Then, back to the calculate prefix sum function, we iterate over each column where each entry jumps by the number of threads. This ensures that all threads accuse their sum assigned to the indexes without overwriting each other. Also, it makes sure that all values in the column indexes are accounted for in the choice of dropping down a number to the left. To do this, we check if the current index is less than 2^i to the right of the start index. If true, we drop down the entry from the current level of computation, or the row, to the next level. In not, we set the value at the index located exactly one row below to the sum of the current entry and the entry located 2^i to the left on the current level of computation.  Finally, we return NULL. 
	Back to main, when creating these threads we set it to a result variable. We can then check if the thread could not be created, and if so, we return an error. After this, we iterate through the threadlist and join each thread. This allows the main function to continue execution once all threads are finished with their individual executions of the Hillis Steele Algorithm. When using the pthread_join function we use the default attributes. Next, we destroy the mutex lock since all of the threads created to compute parts of the prefix sum calculation have terminated. We then print the prefix sum by calling a helper function. 
	In the print prefix sum function, we first obtain the last row of the finished array, since this is where the finished prefix sum calculation is stored. Then, for each entry in the last row, we print the entry. We access the corresponding entry by referencing a quantity containing the current row multiplied by the length of that row and then adding how far into the current level of computation. When finished, we return a NULL value. 
Next, back to the main function, we destroy the condition variable because we have no need for it anymore. If there is an error in this process we return that this is an error and exit(2). Finally, we free the input and the finished array from the heap and then call EXIT_SUCCESS. 
